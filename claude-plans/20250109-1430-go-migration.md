# 3pio Go Migration Plan

## Executive Summary

This plan outlines the migration of 3pio's CLI from TypeScript/Node.js to Go, while maintaining test adapters in their native languages (JavaScript for Jest/Vitest, Python for pytest). The result will be a single compiled binary with bundled adapters, distributed via multiple package managers.

## Objectives & Success Criteria

### Primary Goals
1. **Native Binary Compilation**: Replace Node.js dependency with statically compiled Go binary
2. **Multi-Platform Distribution**: Support npm, pip, brew, cargo, and direct binary downloads
3. **Zero Runtime Dependencies**: CLI requires no language runtimes (except for test framework execution)
4. **Maintained Compatibility**: Preserve existing IPC protocol and adapter interfaces
5. **Performance Improvement**: Faster startup times and lower memory footprint

### Success Metrics
- [ ] Go CLI passes all existing integration tests
- [ ] Binary size < 20MB per platform
- [ ] Startup time < 50ms (vs current ~200ms with Node.js)
- [ ] Works seamlessly with existing Jest/Vitest/pytest adapters
- [ ] Distribution via npm maintains same user experience

## Architecture Design

### Component Distribution

```
3pio/
├── cmd/3pio/          # Go CLI source
├── adapters/          # Native language adapters
│   ├── jest/          # TypeScript/JavaScript
│   ├── vitest/        # TypeScript/JavaScript
│   └── pytest/        # Python
├── internal/          # Go internal packages
│   ├── ipc/           # IPC manager
│   ├── report/        # Report manager
│   ├── runner/        # Test runner abstraction
│   └── utils/         # Utilities
├── dist/              # Build outputs
│   ├── binaries/      # Compiled Go binaries
│   └── adapters/      # Bundled adapter files
└── packaging/         # Package manager configs
    ├── npm/           # package.json + postinstall
    ├── pip/           # setup.py
    └── brew/          # Formula
```

### Go Package Structure

```go
// cmd/3pio/main.go - Entry point
package main

// internal/orchestrator/orchestrator.go
type Orchestrator struct {
    ReportManager *report.Manager
    IPCManager    *ipc.Manager
    RunnerManager *runner.Manager
}

// internal/ipc/manager.go
type Manager struct {
    IPCPath  string
    Watcher  *fsnotify.Watcher
    Events   chan Event
}

// internal/report/manager.go
type Manager struct {
    State        *TestRunState
    OutputParser OutputParser
    FileHandles  map[string]*os.File
    // Debounced write implementation
}

// internal/runner/definitions.go
type RunnerDefinition interface {
    Matches(command []string) bool
    GetTestFiles(args []string) ([]string, error)
    BuildCommand(args []string, adapterPath string) []string
    GetAdapterFileName() string
}
```

## Implementation Phases

### Phase 1: Core Go Implementation (Week 1-2)

#### 1.1 Project Setup
- [ ] Initialize Go module: `go mod init github.com/zk/3pio`
- [ ] Setup project structure with cmd/ and internal/ directories
- [ ] Configure build tooling (Makefile, goreleaser)
- [ ] Setup GitHub Actions for CI/CD

#### 1.2 Core Components
- [ ] Port IPC Manager to Go
  - File-based JSONL communication
  - fsnotify for file watching
  - Event serialization/deserialization
- [ ] Port Report Manager to Go
  - TestRunState management
  - Debounced file writes using time.AfterFunc
  - Dynamic test discovery
  - Incremental log writing
- [ ] Port Test Runner abstraction
  - Jest, Vitest, pytest definitions
  - Command detection and modification
  - Package.json parsing

#### 1.3 CLI Implementation
- [ ] Command-line parsing with cobra or urfave/cli
- [ ] Run command implementation
- [ ] Process spawning with output capture
- [ ] Exit code mirroring
- [ ] Signal handling (Ctrl+C)

### Phase 2: Adapter Bundling (Week 2)

#### 2.1 Adapter Compilation
- [ ] Build TypeScript adapters with esbuild
- [ ] Bundle jest.js and vitest.js
- [ ] Include pytest_adapter.py as-is

#### 2.2 Embedding Strategy
- [ ] Use `go:embed` to include adapters in binary
- [ ] Runtime extraction to temp directory
- [ ] Adapter path resolution

```go
//go:embed dist/adapters/*
var adapterFiles embed.FS

func ExtractAdapter(name string) (string, error) {
    tempDir := filepath.Join(os.TempDir(), "3pio-adapters")
    // Extract adapter to tempDir
    return filepath.Join(tempDir, name), nil
}
```

### Phase 3: Cross-Platform Building (Week 3)

#### 3.1 Build Matrix
- [ ] Linux (amd64, arm64)
- [ ] macOS (amd64, arm64/M1)
- [ ] Windows (amd64)

#### 3.2 Build Automation
```yaml
# .goreleaser.yml
builds:
  - id: 3pio
    main: ./cmd/3pio
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
    hooks:
      pre:
        - npm run build:adapters
```

### Phase 4: Package Manager Integration (Week 3-4)

#### 4.1 NPM Package
```json
{
  "name": "@heyzk/3pio",
  "bin": {
    "3pio": "./bin/3pio"
  },
  "scripts": {
    "postinstall": "node postinstall.js"
  }
}
```

```javascript
// postinstall.js
const platform = process.platform;
const arch = process.arch;
const binaryName = `3pio-${platform}-${arch}`;
// Download appropriate binary from GitHub releases
```

#### 4.2 Python Package
```python
# setup.py
from setuptools import setup
setup(
    name='3pio',
    scripts=['bin/3pio'],
    install_requires=[],
    entry_points={
        'console_scripts': ['3pio=3pio:main'],
    }
)
```

#### 4.3 Homebrew Formula
```ruby
class Threepio < Formula
  desc "AI-first test runner adapter"
  homepage "https://github.com/zk/3pio"
  
  on_macos do
    if Hardware::CPU.arm?
      url "https://github.com/zk/3pio/releases/download/v#{version}/3pio-darwin-arm64.tar.gz"
    else
      url "https://github.com/zk/3pio/releases/download/v#{version}/3pio-darwin-amd64.tar.gz"
    end
  end
  
  on_linux do
    url "https://github.com/zk/3pio/releases/download/v#{version}/3pio-linux-amd64.tar.gz"
  end
end
```

### Phase 5: Testing & Migration (Week 4-5)

#### 5.1 Test Suite
- [ ] Port existing unit tests to Go
- [ ] Integration tests with real Jest/Vitest projects
- [ ] Cross-platform testing matrix
- [ ] Performance benchmarks vs TypeScript version

#### 5.2 Migration Process
- [ ] Feature parity validation
- [ ] Beta testing with early adopters
- [ ] Documentation updates
- [ ] Migration guide for existing users

## Technical Decisions

### Why Go?

**Advantages:**
1. **Single Binary**: Compiles to standalone executable
2. **Cross-Platform**: Excellent cross-compilation support
3. **Performance**: Fast startup, low memory footprint
4. **Concurrency**: Built-in goroutines for IPC handling
5. **Standard Library**: Rich file I/O and process management
6. **Developer Experience**: Simple deployment, no runtime dependencies

**Trade-offs:**
- Loss of JavaScript ecosystem familiarity
- Need to maintain both Go CLI and JS adapters
- Initial development effort for rewrite

### Alternative Considered: Rust
- Pros: Maximum performance, memory safety
- Cons: Steeper learning curve, longer development time

### IPC Protocol Preservation

The file-based JSONL IPC protocol remains unchanged:
- Same event types (testCase, testFileStart, etc.)
- Same file locations (.3pio/ipc/*.jsonl)
- Same environment variable (THREEPIO_IPC_PATH)

This ensures adapters require no modifications.

### Adapter Bundling Strategy

**Embedding in Binary:**
- Use `go:embed` directive for build-time inclusion
- Extract to temp directory on first run
- Cache extracted adapters with version checking

**Benefits:**
- True single-file distribution
- No separate adapter downloads
- Version consistency guaranteed

## Risk Mitigation

### Risk 1: Adapter Compatibility
**Mitigation:** Extensive integration testing with existing adapters

### Risk 2: Platform-Specific Issues
**Mitigation:** CI/CD matrix testing on all target platforms

### Risk 3: Distribution Complexity
**Mitigation:** Automated release pipeline with goreleaser

### Risk 4: User Migration Friction
**Mitigation:** Maintain backward compatibility, clear migration docs

## Implementation Checklist

### Week 1-2: Core Development
- [ ] Setup Go project structure
- [ ] Implement IPC Manager
- [ ] Implement Report Manager
- [ ] Implement Test Runner Manager
- [ ] Create CLI with cobra
- [ ] Add process spawning and output capture

### Week 2: Adapter Integration
- [ ] Build adapter bundling pipeline
- [ ] Implement go:embed extraction
- [ ] Test adapter loading and execution
- [ ] Verify IPC communication

### Week 3: Build Pipeline
- [ ] Setup goreleaser configuration
- [ ] Create GitHub Actions workflow
- [ ] Test cross-platform builds
- [ ] Validate binary sizes

### Week 3-4: Distribution
- [ ] Create npm package wrapper
- [ ] Create pip package wrapper
- [ ] Submit Homebrew formula
- [ ] Setup GitHub releases automation

### Week 4-5: Testing & Polish
- [ ] Port test suite to Go
- [ ] Run integration tests
- [ ] Performance benchmarking
- [ ] Documentation updates
- [ ] Beta testing program

## Performance Targets

| Metric | Current (Node.js) | Target (Go) | Improvement |
|--------|------------------|-------------|-------------|
| Startup Time | ~200ms | <50ms | 4x |
| Memory Usage | ~50MB | <10MB | 5x |
| Binary Size | ~80MB (with Node) | <20MB | 4x |
| IPC Latency | ~5ms | <1ms | 5x |

## Long-term Vision Alignment

This Go migration sets the foundation for:
1. **Universal Test Runner Support**: Easier to add new language adapters
2. **Static Binary Distribution**: True zero-dependency deployment
3. **Performance at Scale**: Handle massive test suites efficiently
4. **Native OS Integration**: Better platform-specific optimizations

## Conclusion

The Go migration represents a significant architectural improvement that will:
- Eliminate runtime dependencies for the CLI
- Improve performance and startup time
- Enable true cross-platform distribution
- Maintain full backward compatibility
- Set foundation for future expansion

The phased approach ensures minimal disruption while delivering substantial benefits to users across all platforms and package managers.